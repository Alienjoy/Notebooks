# 1、为什么现在还有很多使用java8

因为每3年会有一个long term support 版本。现在的LTS是java8，java11，下一个是还没发布的java17

# 2、DAO(Data Access Object)

DAO访问数据的对象

# 3、正则表达式捕获组

![image-20211124141634668](/Users/zhangshuheng/Desktop/Notebooks/JAVA/java面试/01java.assets/image-20211124141634668.png)

正则表达式https://www.runoob.com/java/java-regular-expressions.html

# 4、正则表达式用处

则正表达式是一种匹配规则，是用来筛选我们需要的信息工具，因为计算机大部分处理的信息都是字符串，所有要正则表达式用来匹配和处理字符串，

# 5、时间复杂度大O表示法

当数据结构里面的元素增加时，算法的性能在最坏情况下有多好。表示一个程序运行时所需要的   渐进时间复杂度上界。

# 6、Lambda表达式

当一个方法的参数时接口的实现类对象的时候，我们可以用Lambda表达式来简化书写，前提是这个接口是函数式接口，即只有一个抽象方法的接口。

# 7、符号“==”比较的是什么？

对于对象来说是比较的对象的内存引用，如果两个引用指向同一个对象的时候返回true

对于基本数据类型比较数组

# 8、如果类不重写hashCode的话

直接返回对象的内存地址

# 9、为什么要从写hashCode的同时要重写equals

```
hashCode()方法和equal()方法的作用其实一样，在Java里都是用来对比两个对象是否相等一致，那么equal()既然已经能实现对比的功能了，为什么还要hashCode()呢？
 
因为重写的equal（）里一般比较的比较全面比较复杂，这样效率就比较低，而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？
 
因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠，所以我们可以得出：
 
         1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
         2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。
 
所有对于需要大量并且快速的对比的话如果都用equal()去做显然效率太低，所以解决方式是，每当需要对比的时候，首先用hashCode()去对比，如果hashCode()不一样，则表示这两个对象肯定不相等（也就是不必再用equal()去再对比了）,如果hashCode()相同，此时再对比他们的equal()，如果equal()也相同，则表示这两个对象是真的相同了，这样既能大大提高了效率也保证了对比的绝对正确性
```

