# 1.时间复杂度分析

算法时间复杂度表示方法：

1. 用常数1取代运行时间中的所有加法常数;
2. 在修改后的运行次数中只保留高阶项;
3. 如果最高阶项存在，常数因子不为1，则去除与这个项相乘的常数

# 2.空间复杂度分析

1. 一个引用(机器地址)需要8个字节表示:例如: Date date= new Date()，则date这个变量需要占用8个字节来表示
2. 创建一个对象,比如 new date0,除了Date对象内部存储的数据(例如年月日等信息)占用的内存,该对象本身也有内存开销,每个对象的自身开销是16个字节,用来保存对象的头信息。
3. —般内存的使用,如果不够8个字节,都会被自动填充为8字节:
4. java中数组被被限定为对象,他们一般都会因为记录长度而需要额外的内存,—个原始数据类型的数组一般需要24字节的头信息(16个自己的对象开销,4字节用于保存长度以及4个填充字节)再加上保存值所需的内存

# 3.排序算法

## 3.1 冒泡排序

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007172343024.png" alt="image-20211007172343024" style="zoom:50%;" />

冒泡排序的时间复杂度为O(N^2)

## 3.2 选择排序

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007172510330.png" alt="image-20211007172510330" style="zoom:50%;" />

选择排序的时间复杂度为O(N^2)

## 3.3 插入排序

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007172539338.png" alt="image-20211007172539338" style="zoom:50%;" />

插入排序的时间复杂度为O(N^2)

## 3.4 希尔排序

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007172616655.png" alt="image-20211007172616655" style="zoom:50%;" />

希尔排序原理就是先进行分组，分组后对每一组进行插入排序，使的数组变得部分有序，时间复杂度采用事后分析法来计算。

## 3.5 归并排序

**先对半分，然后再两两合并。**

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007193507479.png" alt="image-20211007193507479" style="zoom:50%;" />

合并的原理，比较p1和p2索引处值的大小，小的放在辅助数组处，然后指针后移。

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007212547633.png" alt="image-20211007212547633" style="zoom:50%;" />

### 归并排序时间复杂度分析

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211008104633936.png" alt="image-20211008104633936" style="zoom:50%;" />

**归并排序的时间复杂度为O(nlogn)**

## 3.6 快速排序

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211007215646066.png" alt="image-20211007215646066" style="zoom:50%;" />





### 快速排序的时间复杂度

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/01数据结构与算法基础.assets/image-20211008104942903.png" alt="image-20211008104942903" style="zoom:50%;" />

# 4.排序算法稳定性

**排序算法的稳定性：**

当遇到两个相同元素时，排序后是否会改变两个相同元素的顺序，因为排序是对对象的一个成员变量排序，假如对手机品牌的销量和价格进行排序的话，如果先排序价格，然后再排序销量会影响之前按照价格排好的顺序，则认为是不稳定的。

如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。

**冒泡排序：**

只有当arr[i]>arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种**稳定排序算法。**

**选择排序:**

选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2， 所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种**不稳定的排序算法**。

**插入排序：**

比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其 后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等 元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是**稳定的。**

**希尔排序：**

希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在 不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是**不稳定的。**

**归并排序：**

归并排序在归并的过程中，只有arr[i]<arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它 并不会破坏稳定性，归并排序是**稳定的。**

**快速排序：**

快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素， 然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种**不稳定的算法**。

