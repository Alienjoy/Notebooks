# 树

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013143012633.png" alt="image-20211013143012633" style="zoom:50%;" />

树具有以下特点：

1.每个结点有零个或多个子结点；

2.没有父结点的结点为根结点；

3.每一个非根结点只有一个父结点；

4.每个结点及其后代结点整体上可以看做是一棵树，称为当前结点的父结点的一个子树；

## 树的相关定义

### 节点的度

一个结点含有的子树的个数称为该结点的度；

### 页节点

度为0的节点。

### 分支节点

度不为0的结点称为分支结点，也可以叫做非终端结点

### 结点的层次：

从根结点开始，根结点的层次为1，根的直接后继层次为2，以此类推

### 结点的层序编号：

将树中的结点，按照从上层到下层，同层从左到右的次序排成一个线性序列，把他们编成连续的自然数。

### 树的度：

树中所有结点的度的最大值

### 树的高度(深度)：

树中结点的最大层次

### 森林：

m（m>=0）个互不相交的树的集合，将一颗非空树的根结点删去，树就变成一个森林；给森林增加一个统一的根 结点，森林就变成一棵树

### 孩子结点：

一个结点的直接后继结点称为该结点的孩子结点

### 双亲结点(父结点)：

一个结点的直接前驱称为该结点的双亲结点

### 兄弟结点：

同一双亲结点的孩子结点间互称兄弟结点

# 二叉树

二叉树就是度不超过2的树(每个结点最多有两个子结点)

**满二叉树：**一个二叉树，如果每一个层的结点树都达到最大值，则这个二叉树就是满二叉树。

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013143720432.png" alt="image-20211013143720432" style="zoom:50%;" />

**完全二叉树：**叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013143753125.png" alt="image-20211013143753125" style="zoom:50%;" />

### 二叉树的内部节点类

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013143832979.png" alt="image-20211013143832979" style="zoom:50%;" />

### 二叉树的API设计

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013143904873.png" alt="image-20211013143904873" style="zoom:50%;" />

## 插入方法put实现思想：

1.如果当前树中没有任何一个结点，则直接把新结点当做根结点使用

2.如果当前树不为空，则从根结点开始：

2.1如果新结点的key小于当前结点的key，则继续找当前结点的左子结点；

2.2如果新结点的key大于当前结点的key，则继续找当前结点的右子结点；

2.3如果新结点的key等于当前结点的key，则树中已经存在这样的结点，替换该结点的value值即可。

## 查询方法get实现思想：

从根节点开始：

1.如果要查询的key小于当前结点的key，则继续找当前结点的左子结点；

2.如果要查询的key大于当前结点的key，则继续找当前结点的右子结点；

3.如果要查询的key等于当前结点的key，则树中返回当前结点的value。

## 删除方法delete实现思想：

1.找到被删除结点；

2.找到被删除结点右子树中的最小结点minNode

3.删除右子树中的最小结点

4.让被删除结点的左子树称为最小结点minNode的左子树，让被删除结点的右子树称为最小结点minNode的右子 树

5.让被删除结点的父节点指向最小结点minNode

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013144227774.png" alt="image-20211013144227774" style="zoom:50%;" />

# 二叉树的遍历

1.前序遍历；

先访问根结点，然后再访问左子树，最后访问右子树

**实现步骤：**

​	1.把当前结点的key放入到队列中;

​	2.找到当前结点的左子树，如果不为空，递归遍历左子树

​	3.找到当前结点的右子树，如果不为空，递归遍历右子树

2.中序遍历；

先访问左子树，中间访问根节点，最后访问右子树

3.后序遍历；

先访问左子树，再访问右子树，最后访问根节点

# 二叉树的层序遍历

1.创建队列，存储每一层的结点；

2.使用循环从队列中弹出一个结点：

2.1获取当前结点的key；

2.2如果当前结点的左子结点不为空，则把左子结点放入到队列中

2.3如果当前结点的右子结点不为空，则把右子结点放入到队列中



<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013144709978.png" alt="image-20211013144709978" style="zoom:50%;" />

# 最大深度

实现步骤：

1.如果根结点为空，则最大深度为0；

2.计算左子树的最大深度；

3.计算右子树的最大深度；

4.当前树的最大深度=左子树的最大深度和右子树的最大深度中的较大者+1 代码：

# 折纸问题

<img src="/Users/zhangshuheng/Desktop/Notebooks/JAVA/数据结构和算法/Untitled.assets/image-20211013144822704.png" alt="image-20211013144822704" style="zoom:50%;" />

主要是二叉树的构建

构建深度为N的折痕树：

1.第一次对折，只有一条折痕，创建根结点；

2.如果不是第一次对折，则使用队列保存根结点；

3.循环遍历队列：（每次遍历队列队列都被重新初始化）

3.1从队列中拿出一个结点；

3.2如果这个结点的左子结点不为空，则把这个左子结点添加到队列中；

3.3如果这个结点的右子结点不为空，则把这个右子结点添加到队列中；

3.4判断当前结点的左子结点和右子结点都不为空，如果是，则需要为当前结点创建一个值为down的左子结点，一 个值为up的右子结点。